<h1>About</h1>
<p><span>網際內容管理課程要求每一位學員利用<span style="text-decoration: underline;"> </span></span><span style="text-decoration: underline;"><span style="color: #000000; text-decoration: underline;"><a href="https://github.com/wcm2022/wcm2022" style="color: #000000; text-decoration: underline;">wcm2022 template</a> 與 <a href="https://pages.github.com/" style="color: #000000; text-decoration: underline;">Github Pages</a></span></span><span><span style="text-decoration: underline;"><span style="color: #000000; text-decoration: underline;"> </span></span>建立名稱為 wcm2022 的倉儲以及網頁. 因此需要在近端執行 Python 程式, 且需要 flask flask_cors bs4 lxml pelican markdown leo pyopenssl 等 Python 模組.</span></p>
<h1>Github使用</h1>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/SCA3GM5FTSo" width="560"></iframe><br/><br/></p>
<h2>如何在倉儲網頁新增影片</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/BeEq2_SqPas" width="560"></iframe></p>
<p>如何新增/推送項目</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/RCy2qS_sjeY" width="560"></iframe></p>
<h1>Midterm</h1>
<p><strong></strong></p>
<p><!--配合 Wink 檔案將 js 檔案設定如下--></p>
<p>
<script>
var winkVideoData = { dataVersion: 1, frameRate: 10, buttonFrameLength: 5, buttonFrameOffset: 2, frameStops: { }, };
</script>
</p>
<!-- 接下來將 mp4 檔案從 downloads 目錄取出 -->
<div class="winkVideoContainerClass"><video autoplay="autoplay" class="winkVideoClass" controls="controls" data-dirname="/static" data-varname="winkVideoData" height="630" muted="true" width="1008">
<source src="/downloads/w8_project.mp4" type="video/mp4"/></video>
<div class="winkVideoOverlayClass"></div>
<div class="winkVideoControlBarClass"><button class="winkVideoControlBarPlayButtonClass"></button> <button class="winkVideoControlBarPauseButtonClass"></button>
<div class="winkVideoControlBarProgressLeftClass"></div>
<div class="winkVideoControlBarProgressEmptyMiddleClass"></div>
<div class="winkVideoControlBarProgressRightClass"></div>
</div>
</div>
<h1>W12</h1>
<p>建立 Virtualbox 虛擬主機</p>
<div class="winkVideoControlBarProgressThumbClass"></div>
<p></p>
<h1>W14</h1>
<!-- 導入 Brython 的程式庫 -->
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython -->
<script>
window.onload=function(){brython();}
</script>
<script type="text/python3">
# from https://levelup.gitconnected.com/writing-tetris-in-python-2a16bddb5318
# 暫時關閉 system proxy 設定後,  pip install pygame
#import pygame
# 將 pygame 動畫繪圖轉為 Brython
'''
為能在 script src 中導入, 必須將 .py 程式內容透過 cp-to-txt 複製到 .txt
'''

# 這個程式用於 demo 綠色方塊往隨機產生的紅色方塊位置移動
# 此程式並未計算各紅色方塊與綠色方塊的距離, 僅按照隨機排序移動
# 從 Brython 程式庫中的 browser 模組導入 document 類別, 並以簡寫設定為 doc
from browser import document as doc
# 從 browser 模組導入 html 類別, 主要用於建立 CANVAS 標註物件, 並插入頁面中
from browser import html
# 用於定時執行特定函式
import browser.timer
# 導入亂數模組
from random import random, randint

# 利用 html 建立一個 CANVAS 標註物件, 與變數 canvas 對應
canvas = html.CANVAS(width = 600, height = 600)
# 將 canvas 標註的 id 設為 "canvas"
canvas.id = "canvas"
# 將 document 中 id 為 "brython_div" 的標註 
# 設為與 brython_div 變數對應
brython_div = doc["brython_div"]
# 將 canvas 標註放入 brython_div 所在位置
# 頁面中原本就已經放入 <div id="brython_div"></div> 標註
brython_div <= canvas
# 將頁面中 id 為 canvas 的 CANVAS 設為與 canvas 變數對應
canvas = doc["canvas"]
# 將 canvas 的 2d 繪圖 context 命名為 ctx
ctx = canvas.getContext("2d")

# 建立一個 dRect() 函式
# s default 為 1, c default 為紅色
def dRect(lux, luy, w, h, s=1, c='#ff0000'):
    ctx.lineWidth = s
    ctx.strokeStyle = c
    ctx.beginPath();
    ctx.rect(lux, luy, w, h)
    ctx.stroke();
    
# 建立畫直線函式
def draw_line(x1, y1, x2, y2, color="#ff0000"):
    ctx.beginPath()
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.strokeStyle = color
    ctx.stroke()

# 建立 write Text 函式
def wText(x, y, t, s=14, c='#0000ff'):
    ctx.font = str(s) + "px Arial";
    ctx.fillText(t, x, y)

# 定義畫格線的函式
def grid(startx, starty, w, h, wnum, hnum, pixel=1, color="#ff0000"):
    # 利用迴圈與座標增量繪圖
    # 因為輸入 wnum 與 hnum 為格子數, 畫格線數則需加上 1
    for i in range(wnum+1):
        for j in range(hnum+1):
            # 畫上下直線
            yend = starty + h*(hnum)
            xend = startx + w*(wnum)
            x = startx + i*w
            draw_line(x, starty, x, yend, color)
            # 畫左右直線
            y = starty + j*h
            draw_line(startx, y, xend, y, color)
            #wText(w/2-10, y-w/2, str(j))

# 從兩個座標點求中心點座標
def center(lx, ly, rx, ry):
    # lx is x coord of the left up corner
    # rx is the x coord of th right down corner
    x = (lx + rx)/2
    y = (ly + ry)/2
    return x, y
    
# 畫出填色方塊
def draw_rect(gx, gy, gw, gh, color="lime"):
    # gx is the grid coord at x direction
    # gy is the grid coord at y direction
    # gw is the width of the green rect
    # gh is the height of the green rect
    lx = origx + (gx-1)*w
    ly = origy + (gy-1)*h
    rx = origx + gx*w
    ry = origy + gy*h
    cx, cy = center(lx, ly, rx, ry)
    # glx is the x coord of the left corner
    # gly is the y coord of the left corner
    glx = cx - gw/2
    gly = cy - gh/2
    # 利用設定的顏色值畫出 rectangle
    ctx.fillStyle = color
    ctx.fillRect(glx, gly, gw, gh)

# 以白色覆蓋位於 (nowx, nowy) 
# 且比目標方塊長寬各大於 1 pixel的方塊
def wipe():
    draw_rect(nowx, nowy, 30+1, 30+1, color="white")

# 畫出位於 (nowx, nowy) 的綠色方塊
def draw():
    draw_rect(nowx, nowy, 30, 30, color="lime")

# 以隨機方式在格點座標中畫出紅色方塊
def draw_red(x, y):
    draw_rect(x, y, wrect_size, hrect_size, color="red")

# 綠色方塊往紅色方塊位置移動, 抵達目標位置後停止移動
def walk():
    global stepx, stepy
    if nowx > redx:
        stepx = -1
        stepy = 0
    if nowx < redx:
        stepx = 1
        stepy = 0
    if nowy > redy:
        stepx = 0
        stepy = -1
    if nowy < redy:
        stepx = 0
        stepy = 1
    if nowx == redx and nowy == redy:
        stepx = 0
        stepy = 0

# 每隔短暫時間即呼叫執行一次的函式
def game():
    # 因 nowx, nowy, redx, redy 在函式外宣告
    # 且在函式內改變對應值, 因此需宣告為 global
    global nowx, nowy, redx, redy
    # 當綠色方塊移動至紅色方塊座標後, 逐一取出另一個紅色目標座標值
    if nowx == redx and nowy == redy:
        # 利用 pop() 逐一取出 coord 中的座標值 pos
        # coord 取至最後一個數列後, 即跳至 pass
        try:
            pos = coord.pop()
            # 索引 0 為 x 座標, 1 為 y 座標
            redx = pos[0]
            redy = pos[1]
            wText(int((redx-0.5)*w), int((redy-0.5)*h), "O")
        except:
            # 以隨機方產生 5 個座標值
            for i in range(5):
                # wnum 為 width 方向的格子數
                # hnum 為 height 方向的格子數
                x = randint(1, wnum)
                y = randint(1, hnum)
                # 逐一在座標位置畫出紅色方塊
                draw_red(x, y)
                # 將座標值以數列方式放入 coord 數列
                coord.append([x, y])
    walk()
    wipe()
    nowx += stepx
    nowy += stepy
    draw()

# 綠色方塊起點座標與 x 及 y 方向的座標增量
nowx = 1
nowy = 1
stepx = 0
stepy = 0
go = True
# 設定格數
# width 方向格子數
wnum = 15
# height 方向格子數
hnum = 15
# 紅色方塊座標起始座標位於右下角
redx = wnum-1
redy = hnum-1
# 設定線寬
pixel = 1
# 設定 w 寬度
w = int(canvas.width/wnum) - pixel
# 設定 h 高度
h = int(canvas.height/hnum) - pixel
# 設定紅色方塊寬度與高度, 分別設為格子大小的  70%
wrect_size = int(w*0.7)
hrect_size = int(h*0.7)
# 設定繪圖座標點起點位置
origx = 1
origy = 1
# 利用 grid 函式畫出格線
grid(origx, origy, w, h, wnum, hnum, pixel=1, color="black")

# 宣告 coord 為數列
coord = []
# 以隨機方產生 5 個座標值
for i in range(5):
    # wnum 為 width 方向的格子數
    # hnum 為 height 方向的格子數
    x = randint(1, wnum)
    y = randint(1, hnum)
    # 逐一在座標位置畫出紅色方塊
    draw_red(x, y)
    # 將座標值以數列方式放入 coord 數列
    coord.append([x, y])

browser.timer.set_interval(game, 100)
</script>
<h1>W16</h1>
<!-- 導入 Brython 的程式庫 -->
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython -->
<script>
window.onload=function(){brython();}
</script>
<script type="text/python3">
# from https://levelup.gitconnected.com/writing-tetris-in-python-2a16bddb5318
# 暫時關閉 system proxy 設定後,  pip install pygame
#import pygame
# 將 pygame 動畫繪圖轉為 Brython
'''
為能在 script src 中導入, 必須將 .py 程式內容透過 cp-to-txt 複製到 .txt
'''
# 導入 random 模組
import random
# 以下為 Brython 新增
from browser import document as doc
from browser import html
import browser.timer

# 利用 html 建立一個 CANVAS 標註物件, 與變數 canvas 對應
canvas = html.CANVAS(width = 400, height = 500, id="canvas")
brython_div = doc["brython_div"]
brython_div <= canvas
ctx = canvas.getContext("2d")

# 定義顏色值數列
colors = [
    (0, 0, 0),
    (120, 37, 179),
    (100, 179, 179),
    (80, 34, 22),
    (80, 134, 22),
    (180, 34, 22),
    (180, 34, 122),
]
class Figure:
    # 定義圖形 (Figure) 類別
    x = 0
    y = 0

    figures = [
        [[1, 5, 9, 13], [4, 5, 6, 7]],
        [[4, 5, 9, 10], [2, 6, 5, 9]],
        [[6, 7, 9, 10], [1, 5, 6, 10]],
        [[1, 2, 5, 9], [0, 4, 5, 6], [1, 5, 9, 8], [4, 5, 6, 10]],
        [[1, 2, 6, 10], [5, 6, 7, 9], [2, 6, 10, 11], [3, 5, 6, 7]],
        [[1, 4, 5, 6], [1, 4, 5, 9], [4, 5, 6, 9], [1, 5, 6, 9]],
        [[1, 2, 5, 6]],
    ]

    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.type = random.randint(0, len(self.figures) - 1)
        self.color = random.randint(1, len(colors) - 1)
        self.rotation = 0

    def image(self):
        return self.figures[self.type][self.rotation]

    def rotate(self):
        self.rotation = (self.rotation + 1) % len(self.figures[self.type])


class Tetris:
    level = 0.5
    score = 0
    state = "start"
    field = []
    height = 0
    width = 0
    x = 100
    y = 60
    zoom = 20
    figure = None

    def __init__(self, height, width):
        self.height = height
        self.width = width
        self.field = []
        self.score = 0
        self.state = "start"
        for i in range(height):
            new_line = []
            for j in range(width):
                # 起始時每一個都填入 0
                new_line.append(0)
            self.field.append(new_line)

    def new_figure(self):
        self.figure = Figure(3, 0)

    def intersects(self):
        intersection = False
        for i in range(4):
            for j in range(4):
                if i * 4 + j in self.figure.image():
                    # block 到達底部, 左右兩邊界, 或該座標有其他 block
                    if i + self.figure.y > self.height - 1 or \
                            j + self.figure.x > self.width - 1 or \
                            j + self.figure.x < 0 or \
                            self.field[i + self.figure.y][j + self.figure.x] > 0:
                        intersection = True
        return intersection

    def break_lines(self):
        lines = 0
        for i in range(1, self.height):
            zeros = 0
            for j in range(self.width):
                if self.field[i][j] == 0:
                    zeros += 1
            if zeros == 0:
                lines += 1
                for i1 in range(i, 1, -1):
                    for j in range(self.width):
                        self.field[i1][j] = self.field[i1 - 1][j]
        self.score += lines ** 2

    def go_space(self):
        while not self.intersects():
            self.figure.y += 1
        self.figure.y -= 1
        self.freeze()

    def go_down(self):
        self.figure.y += 1
        if self.intersects():
            self.figure.y -= 1
            self.freeze()

    def freeze(self):
        for i in range(4):
            for j in range(4):
                if i * 4 + j in self.figure.image():
                    self.field[i + self.figure.y][j + self.figure.x] = self.figure.color
        self.break_lines()
        self.new_figure()
        if self.intersects():
            self.state = "gameover"

    def go_side(self, dx):
        old_x = self.figure.x
        self.figure.x += dx
        if self.intersects():
            self.figure.x = old_x

    def rotate(self):
        old_rotation = self.figure.rotation
        self.figure.rotate()
        if self.intersects():
            self.figure.rotation = old_rotation

# Define some colors
# from https://stackoverflow.com/questions/3380726/converting-a-rgb-color-tuple-to-a-six-digit-code
BLACK = '#%02x%02x%02x' % (0, 0, 0)
WHITE = '#%02x%02x%02x' % (255, 255, 255)
GRAY = '#%02x%02x%02x' % (128, 128, 128)

done = False
fps = 25
game = Tetris(20, 10)
counter = 0

pressing_down = False

def key_down(eve):
    key = eve.keyCode
    #if event.type == pygame.QUIT:
    # 32 is pause
    if key == 32:
        done = True
    # 82 is r key to rotate
    if key == 82:
        game.rotate()
    # 40 is down key
    if key == 40:
        pressing_down = True
    # 37 is left key
    if key == 37:
        game.go_side(-1)
    # 39 is right key
    if key == 39:
        game.go_side(1)
    # 68 is d key to move block to bottom
    if key == 68:
        game.go_space()
    # 27 is escape
    # reset the game
    if key == 27:
        game.__init__(20, 10)

def key_up(eve):
    key = eve.keyCode
    # 40 is down key
    if key == 40:
        pressing_down = False

#while not done:
def do_game():
    global counter
    if game.figure is None:
        game.new_figure()
    counter += 1
    if counter > 100000:
        counter = 0
    if counter % (fps // game.level // 2) == 0 or pressing_down:
        if game.state == "start":
            game.go_down()
    
    for i in range(game.height):
        for j in range(game.width):
            ctx.fillStyle = WHITE
            #ctx.scale(game.zoom, game.zoom)
            ctx.fillRect(game.x + game.zoom * j, game.y + game.zoom * i, game.zoom, game.zoom)
            if game.field[i][j] > 0:
                ctx.fillStyle = '#%02x%02x%02x' % colors[game.field[i][j]]
                ctx.fillRect(game.x + game.zoom * j + 1, game.y + game.zoom * i + 1, game.zoom - 2, game.zoom - 1)
            ctx.lineWidth = 1
            ctx.strokeStyle = GRAY
            ctx.beginPath()
            ctx.rect(game.x + game.zoom * j, game.y + game.zoom * i, game.zoom, game.zoom)
            ctx.stroke()
    if game.figure is not None:
        for i in range(4):
            for j in range(4):
                p = i * 4 + j
                if p in game.figure.image():
                    ctx.fillStyle = '#%02x%02x%02x' % colors[game.figure.color]
                    ctx.fillRect(game.x + game.zoom * (j + game.figure.x) + 1,
                                      game.y + game.zoom * (i + game.figure.y) + 1,
                                      game.zoom - 2, game.zoom - 2)

   # 宣告文字的大小為36px
    ctx.font = '36px serif'
    # 宣告文字顏色為黑色
    ctx.fillStyle = BLACK
    # 將分數顯示在遊戲區上方, 座標為(10, 50), 並設定變數為text
    ctx.fillText('Score:'+ str(game.score), 10,50)
    
    # 宣告變數int = 1 ，如果分數大於int，則畫布清掉原本的分數填上新的得分分數
    int = 1
    if game.score >= int:
        ctx.fillStyle =WHITE
        ctx.fillRect( 108, 0, 200, 50)
        ctx.fillStyle = BLACK
        ctx.fillText(str(game.score), 108,50)

doc.addEventListener("keydown", key_down)
doc.addEventListener("keyup", key_up)
browser.timer.set_interval(do_game, fps)
</script>
<div id="brython_div">
<p>重新使用pull requestes建立倉儲 </p>
<p>盡速了解最後瞭周評分標準</p>
<p></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/sIheGukuC7Q" width="560"></iframe></p>
</div>
<h1>W17</h1>
<p>記分板出問題:(</p>
<div id="brython_div">
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/-4ZhwASdPm0" width="560"></iframe>可顯示數字 social credit+100</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/Qi8WgyNKEt4" width="560"></iframe></p>
</div>
<p><strong></strong></p>
<p><!--配合 Wink 檔案將 js 檔案設定如下--></p>
<p>
<script>
var winkVideoData = { dataVersion: 1, frameRate: 10, buttonFrameLength: 5, buttonFrameOffset: 2, frameStops: { }, };
</script>
</p>
<!-- 接下來將 mp4 檔案從 downloads 目錄取出 -->
<div class="winkVideoContainerClass"><video autoplay="autoplay" class="winkVideoClass" controls="controls" data-dirname="/static" data-varname="winkVideoData" height="630" muted="true" width="1008">
<source src="/downloads/Tetris.mp4" type="video/mp4"/></video>
<div class="winkVideoOverlayClass"></div>
<div class="winkVideoControlBarClass"><button class="winkVideoControlBarPlayButtonClass"></button> <button class="winkVideoControlBarPauseButtonClass"></button>
<div class="winkVideoControlBarProgressLeftClass"></div>
<div class="winkVideoControlBarProgressEmptyMiddleClass"></div>
<div class="winkVideoControlBarProgressRightClass"></div>
</div>
</div>
<h1>W18期末任務2</h1>
<p></p>
<!-- 導入 Brython 的程式庫 -->
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython -->
<script>
window.onload=function(){brython();}
</script>
<script type="text/python3">
# from https://levelup.gitconnected.com/writing-tetris-in-python-2a16bddb5318
# 暫時關閉 system proxy 設定後,  pip install pygame
#import pygame
# 將 pygame 動畫繪圖轉為 Brython
'''
為能在 script src 中導入, 必須將 .py 程式內容透過 cp-to-txt 複製到 .txt
'''
# from https://levelup.gitconnected.com/writing-tetris-in-python-2a16bddb5318
# 改為可自動執行模式
import random
# 以下為 Brython 新增
from browser import document as doc
from browser import html
import browser.timer

def intersects(game_field, x, y, game_width, game_height, game_figure_image):
    intersection = False
    for i in range(4):
        for j in range(4):
            if i * 4 + j in game_figure_image:
                if i + y > game_height - 1 or \
                        j + x > game_width - 1 or \
                        j + x < 0 or \
                        game_field[i + y][j + x] > 0:
                    intersection = True
    return intersection

def simulate(game_field, x, y, game_width, game_height, game_figure_image):
    while not intersects(game_field, x, y, game_width, game_height, game_figure_image):
        y += 1
    y -= 1

    height = game_height
    holes = 0
    filled = []
    breaks = 0
    for i in range(game_height-1, -1, -1):
        it_is_full = True
        prev_holes = holes
        for j in range(game_width):
            u = '_'
            if game_field[i][j] != 0:
                u = "x"
            for ii in range(4):
                for jj in range(4):
                    if ii * 4 + jj in game_figure_image:
                        if jj + x == j and ii + y == i:
                            u = "x"

            if u == "x" and i < height:
                height = i
            if u == "x":
                filled.append((i, j))
                for k in range(i, game_height):
                    if (k, j) not in filled:
                        holes += 1
                        filled.append((k,j))
            else:
                it_is_full = False
        if it_is_full:
            breaks += 1
            holes = prev_holes

    return holes, game_height-height-breaks

def best_rotation_position(game_field, game_figure, game_width, game_height):
    best_height = game_height
    best_holes = game_height*game_width
    best_position = None
    best_rotation = None

    for rotation in range(len(game_figure.figures[game_figure.type])):
        fig = game_figure.figures[game_figure.type][rotation]
        for j in range(-3, game_width):
            if not intersects(
                    game_field,
                    j,
                    0,
                    game_width,
                    game_height,
                    fig):
                holes, height = simulate(
                    game_field,
                    j,
                    0,
                    game_width,
                    game_height,
                    fig
                )
                if best_position is None or best_holes > holes or \
                    best_holes == holes and best_height > height:
                    best_height = height
                    best_holes = holes
                    best_position = j
                    best_rotation = rotation
    return best_rotation, best_position

# 建立一個自動執行的函式
# step 1
'''
def run_ai():
    game.rotate()
'''
#step 2
def run_ai(game_field, game_figure, game_width, game_height):
    rotation, position = best_rotation_position(game_field, game_figure, game_width, game_height)
    if game_figure.rotation != rotation:
        game.rotate()
    elif game_figure.x < position:
        game.go_side(1)
    elif game_figure.x > position:
        game.go_side(-1)
    else:
        game.go_space()

# 利用 html 建立一個 CANVAS 標註物件, 與變數 canvas 對應
canvas = html.CANVAS(width = 400, height = 500, id="canvas")
brython_div = doc["brython_div"]
brython_div <= canvas
ctx = canvas.getContext("2d")

colors = [
    (0, 0, 0),
    (120, 37, 179),
    (100, 179, 179),
    (80, 34, 22),
    (80, 134, 22),
    (180, 34, 22),
    (180, 34, 122),
]


class Figure:
    x = 0
    y = 0

    figures = [
        [[1, 5, 9, 13], [4, 5, 6, 7]],
        [[4, 5, 9, 10], [2, 6, 5, 9]],
        [[6, 7, 9, 10], [1, 5, 6, 10]],
        [[1, 2, 5, 9], [0, 4, 5, 6], [1, 5, 9, 8], [4, 5, 6, 10]],
        [[1, 2, 6, 10], [5, 6, 7, 9], [2, 6, 10, 11], [3, 5, 6, 7]],
        [[1, 4, 5, 6], [1, 4, 5, 9], [4, 5, 6, 9], [1, 5, 6, 9]],
        [[1, 2, 5, 6]],
    ]

    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.type = random.randint(0, len(self.figures) - 1)
        self.color = random.randint(1, len(colors) - 1)
        self.rotation = 0

    def image(self):
        return self.figures[self.type][self.rotation]

    def rotate(self):
        self.rotation = (self.rotation + 1) % len(self.figures[self.type])


class Tetris:
    level = 2
    score = 0
    state = "start"
    field = []
    height = 0
    width = 0
    x = 100
    y = 60
    zoom = 20
    figure = None

    def __init__(self, height, width):
        self.height = height
        self.width = width
        self.field = []
        self.score = 0
        self.state = "start"
        for i in range(height):
            new_line = []
            for j in range(width):
                # 起始時每一個都填入 0
                new_line.append(0)
            self.field.append(new_line)

    def new_figure(self):
        self.figure = Figure(3, 0)

    def intersects(self):
        intersection = False
        for i in range(4):
            for j in range(4):
                if i * 4 + j in self.figure.image():
                    # block 到達底部, 左右兩邊界, 或該座標有其他 block
                    if i + self.figure.y > self.height - 1 or \
                            j + self.figure.x > self.width - 1 or \
                            j + self.figure.x < 0 or \
                            self.field[i + self.figure.y][j + self.figure.x] > 0:
                        intersection = True
        return intersection

    def break_lines(self):
        lines = 0
        for i in range(1, self.height):
            zeros = 0
            for j in range(self.width):
                if self.field[i][j] == 0:
                    zeros += 1
            if zeros == 0:
                lines += 1
                for i1 in range(i, 1, -1):
                    for j in range(self.width):
                        self.field[i1][j] = self.field[i1 - 1][j]
        self.score += lines ** 2

    def go_space(self):
        while not self.intersects():
            self.figure.y += 1
        self.figure.y -= 1
        self.freeze()

    def go_down(self):
        self.figure.y += 1
        if self.intersects():
            self.figure.y -= 1
            self.freeze()

    def freeze(self):
        for i in range(4):
            for j in range(4):
                if i * 4 + j in self.figure.image():
                    self.field[i + self.figure.y][j + self.figure.x] = self.figure.color
        self.break_lines()
        self.new_figure()
        if self.intersects():
            self.state = "gameover"

    def go_side(self, dx):
        old_x = self.figure.x
        self.figure.x += dx
        if self.intersects():
            self.figure.x = old_x

    def rotate(self):
        old_rotation = self.figure.rotation
        self.figure.rotate()
        if self.intersects():
            self.figure.rotation = old_rotation

# Define some colors
# from https://stackoverflow.com/questions/3380726/converting-a-rgb-color-tuple-to-a-six-digit-code
BLACK = '#%02x%02x%02x' % (0, 0, 0)
WHITE = '#%02x%02x%02x' % (255, 255, 255)
GRAY = '#%02x%02x%02x' % (128, 128, 128)
RED = '#%02x%02x%02x' % (255, 0, 0)

done = False
fps = 5
game = Tetris(20, 10)
counter = 0

pressing_down = False

def key_down(eve):
    key = eve.keyCode
    #if event.type == pygame.QUIT:
    # 32 is pause
    if key == 32:
        done = True
    # 82 is r key to rotate
    if key == 82:
        game.rotate()
    # 40 is down key
    if key == 40:
        pressing_down = True
    # 37 is left key
    if key == 37:
        game.go_side(-1)
    # 39 is right key
    if key == 39:
        game.go_side(1)
    # 68 is d key to move block to bottom
    if key == 68:
        game.go_space()
    # 27 is escape
    # reset the game
    if key == 27:
        # clear the previous score
        ctx.fillStyle = WHITE
        ctx.fillRect( 100, 0, 200, 50)
        game.__init__(20, 10)

def key_up(eve):
    key = eve.keyCode
    # 40 is down key
    if key == 40:
        pressing_down = False

#while not done:
def do_game():
    global counter
    if game.figure is None:
        game.new_figure()
    counter += 1
    if counter > 100000:
        counter = 0
    if counter % (fps // game.level // 2) == 0 or pressing_down:
        if game.state == "start":
            game.go_down()
            run_ai(game.field, game.figure, game.width, game.height)
    
    for i in range(game.height):
        for j in range(game.width):
            ctx.fillStyle = WHITE
            #ctx.scale(game.zoom, game.zoom)
            ctx.fillRect(game.x + game.zoom * j, game.y + game.zoom * i, game.zoom, game.zoom)
            if game.field[i][j] > 0:
                ctx.fillStyle = '#%02x%02x%02x' % colors[game.field[i][j]]
                ctx.fillRect(game.x + game.zoom * j + 1, game.y + game.zoom * i + 1, game.zoom - 2, game.zoom - 1)
            ctx.lineWidth = 1
            ctx.strokeStyle = GRAY
            ctx.beginPath()
            ctx.rect(game.x + game.zoom * j, game.y + game.zoom * i, game.zoom, game.zoom)
            ctx.stroke()
    if game.figure is not None:
        for i in range(4):
            for j in range(4):
                p = i * 4 + j
                if p in game.figure.image():
                    ctx.fillStyle = '#%02x%02x%02x' % colors[game.figure.color]
                    ctx.fillRect(game.x + game.zoom * (j + game.figure.x) + 1,
                                      game.y + game.zoom * (i + game.figure.y) + 1,
                                      game.zoom - 2, game.zoom - 2)

# score and Game Over scripts from https://s40723245.github.io/wcm2022
    # 宣告文字的大小為36px
    ctx.font = '36px serif'
    # 宣告文字顏色為黑色
    ctx.fillStyle = BLACK
    # 將分數顯示在遊戲區上方, 座標為(10, 50), 並設定變數為text
    ctx.fillText('Score:'+ str(game.score), 10,50)
    
    # 宣告變數int = 1 ，如果分數大於int，則畫布清掉原本的分數填上新的得分分數
    int = 1
    if game.score >= int:
        ctx.fillStyle = WHITE
        ctx.fillRect( 100, 0, 200, 50)
        ctx.fillStyle = BLACK
        ctx.fillText(str(game.score), 108,50)
    
    # 如果遊戲狀態為gameover，顯示Game Over及Press ESC，並將文字設定為紅色
    if game.state == "gameover":
        ctx.fillStyle = RED
        ctx.fillText("Game Over", 100, 200)
        ctx.fillText("Press ESC", 105, 265)
        ctx.fillStyle = WHITE
        ctx.fillRect( 100, 0, 200, 50)
        game.__init__(20, 10)

doc.addEventListener("keydown", key_down)
doc.addEventListener("keyup", key_up)
browser.timer.set_interval(do_game, fps)
</script>
<div id="brython_div">
<script>
var winkVideoData = { dataVersion: 1, frameRate: 10, buttonFrameLength: 5, buttonFrameOffset: 2, frameStops: { }, };
</script>
<p></p>
<p></p>
</div><h1>W18期末任務1</h1>
<p>在字串"ctx = canvas.getContext("2d")"之後</p>
<p>新增字串"ctx.translate(0,canvas.height)"</p>
<p>用來將y方向零點設置從底部改至頂部<br/>新增字串"ctx.scale(1,-1)"</p>
<p>用來將y方向縮放-1倍</p>
<p></p>
<!-- 導入 Brython 的程式庫 -->
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython -->
<script>
window.onload=function(){brython();}
</script>
<script type="text/python3">
# from https://levelup.gitconnected.com/writing-tetris-in-python-2a16bddb5318
# 暫時關閉 system proxy 設定後,  pip install pygame
#import pygame
# 將 pygame 動畫繪圖轉為 Brython
'''
為能在 script src 中導入, 必須將 .py 程式內容透過 cp-to-txt 複製到 .txt
'''
# 導入 random 模組
import random
# 以下為 Brython 新增
from browser import document as doc
from browser import html
import browser.timer

# 利用 html 建立一個 CANVAS 標註物件, 與變數 canvas 對應
canvas = html.CANVAS(width = 400, height = 500, id="canvas")
brython_div = doc["brython_div"]
brython_div <= canvas
ctx = canvas.getContext("2d")


ctx.translate(0,canvas.height)#將y方向零點設置在原本高的底部
ctx.scale(1,-1)#將y方向縮放-1倍

# 定義顏色值數列
colors = [
    (0, 0, 0),
    (120, 37, 179),
    (100, 179, 179),
    (80, 34, 22),
    (80, 134, 22),
    (180, 34, 22),
    (180, 34, 122),
]
class Figure:
    # 定義圖形 (Figure) 類別
    x = 0
    y = 0

    figures = [
        [[1, 5, 9, 13], [4, 5, 6, 7]],
        [[4, 5, 9, 10], [2, 6, 5, 9]],
        [[6, 7, 9, 10], [1, 5, 6, 10]],
        [[1, 2, 5, 9], [0, 4, 5, 6], [1, 5, 9, 8], [4, 5, 6, 10]],
        [[1, 2, 6, 10], [5, 6, 7, 9], [2, 6, 10, 11], [3, 5, 6, 7]],
        [[1, 4, 5, 6], [1, 4, 5, 9], [4, 5, 6, 9], [1, 5, 6, 9]],
        [[1, 2, 5, 6]],
    ]

    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.type = random.randint(0, len(self.figures) - 1)
        self.color = random.randint(1, len(colors) - 1)
        self.rotation = 0

    def image(self):
        return self.figures[self.type][self.rotation]

    def rotate(self):
        self.rotation = (self.rotation + 1) % len(self.figures[self.type])


class Tetris:
    level = 0.5
    score = 0
    state = "start"
    field = []
    height = 0
    width = 0
    x = 100
    y = 60
    zoom = 20
    figure = None

    def __init__(self, height, width):
        self.height = height
        self.width = width
        self.field = []
        self.score = 0
        self.state = "start"
        for i in range(height):
            new_line = []
            for j in range(width):
                # 起始時每一個都填入 0
                new_line.append(0)
            self.field.append(new_line)

    def new_figure(self):
        self.figure = Figure(3, 0)

    def intersects(self):
        intersection = False
        for i in range(4):
            for j in range(4):
                if i * 4 + j in self.figure.image():
                    # block 到達底部, 左右兩邊界, 或該座標有其他 block
                    if i + self.figure.y > self.height - 1 or \
                            j + self.figure.x > self.width - 1 or \
                            j + self.figure.x < 0 or \
                            self.field[i + self.figure.y][j + self.figure.x] > 0:
                        intersection = True
        return intersection

    def break_lines(self):
        lines = 0
        for i in range(1, self.height):
            zeros = 0
            for j in range(self.width):
                if self.field[i][j] == 0:
                    zeros += 1
            if zeros == 0:
                lines += 1
                for i1 in range(i, 1, -1):
                    for j in range(self.width):
                        self.field[i1][j] = self.field[i1 - 1][j]
        self.score += lines ** 2

    def go_space(self):
        while not self.intersects():
            self.figure.y += 1
        self.figure.y -= 1
        self.freeze()

    def go_down(self):
        self.figure.y += 1
        if self.intersects():
            self.figure.y -= 1
            self.freeze()

    def freeze(self):
        for i in range(4):
            for j in range(4):
                if i * 4 + j in self.figure.image():
                    self.field[i + self.figure.y][j + self.figure.x] = self.figure.color
        self.break_lines()
        self.new_figure()
        if self.intersects():
            self.state = "gameover"

    def go_side(self, dx):
        old_x = self.figure.x
        self.figure.x += dx
        if self.intersects():
            self.figure.x = old_x

    def rotate(self):
        old_rotation = self.figure.rotation
        self.figure.rotate()
        if self.intersects():
            self.figure.rotation = old_rotation

# Define some colors
# from https://stackoverflow.com/questions/3380726/converting-a-rgb-color-tuple-to-a-six-digit-code
BLACK = '#%02x%02x%02x' % (0, 0, 0)
WHITE = '#%02x%02x%02x' % (255, 255, 255)
GRAY = '#%02x%02x%02x' % (128, 128, 128)

done = False
fps = 25
game = Tetris(20, 10)
counter = 0

pressing_down = False

def key_down(eve):
    key = eve.keyCode
    #if event.type == pygame.QUIT:
    # 32 is pause
    if key == 32:
        done = True
    # 82 is r key to rotate
    if key == 82:
        game.rotate()
    # 40 is down key
    if key == 40:
        pressing_down = True
    # 37 is left key
    if key == 37:
        game.go_side(-1)
    # 39 is right key
    if key == 39:
        game.go_side(1)
    # 68 is d key to move block to bottom
    if key == 68:
        game.go_space()
    # 27 is escape
    # reset the game
    if key == 27:
        game.__init__(20, 10)

def key_up(eve):
    key = eve.keyCode
    # 40 is down key
    if key == 40:
        pressing_down = False

#while not done:
def do_game():
    global counter
    if game.figure is None:
        game.new_figure()
    counter += 1
    if counter > 100000:
        counter = 0
    if counter % (fps // game.level // 2) == 0 or pressing_down:
        if game.state == "start":
            game.go_down()
    
    for i in range(game.height):
        for j in range(game.width):
            ctx.fillStyle = WHITE
            #ctx.scale(game.zoom, game.zoom)
            ctx.fillRect(game.x + game.zoom * j, game.y + game.zoom * i, game.zoom, game.zoom)
            if game.field[i][j] > 0:
                ctx.fillStyle = '#%02x%02x%02x' % colors[game.field[i][j]]
                ctx.fillRect(game.x + game.zoom * j + 1, game.y + game.zoom * i + 1, game.zoom - 2, game.zoom - 1)
            ctx.lineWidth = 1
            ctx.strokeStyle = GRAY
            ctx.beginPath()
            ctx.rect(game.x + game.zoom * j, game.y + game.zoom * i, game.zoom, game.zoom)
            ctx.stroke()
    if game.figure is not None:
        for i in range(4):
            for j in range(4):
                p = i * 4 + j
                if p in game.figure.image():
                    ctx.fillStyle = '#%02x%02x%02x' % colors[game.figure.color]
                    ctx.fillRect(game.x + game.zoom * (j + game.figure.x) + 1,
                                      game.y + game.zoom * (i + game.figure.y) + 1,
                                      game.zoom - 2, game.zoom - 2)

   # 宣告文字的大小為36px
    ctx.font = '36px serif'
    # 宣告文字顏色為黑色
    ctx.fillStyle = BLACK
    # 將分數顯示在遊戲區上方, 座標為(10, 50), 並設定變數為text
    ctx.fillText('Score:'+ str(game.score), 10,50)
    
    # 宣告變數int = 1 ，如果分數大於int，則畫布清掉原本的分數填上新的得分分數
    int = 1
    if game.score >= int:
        ctx.fillStyle =WHITE
        ctx.fillRect( 108, 0, 200, 50)
        ctx.fillStyle = BLACK
        ctx.fillText(str(game.score), 108,50)

doc.addEventListener("keydown", key_down)
doc.addEventListener("keyup", key_up)
browser.timer.set_interval(do_game, fps)
</script>
<div id="brython_div">
<p></p>
<p></p>
<p></p>
<p><strong></strong></p>
<p><!--配合 Wink 檔案將 js 檔案設定如下--></p>
<p>
<script>
var winkVideoData = { dataVersion: 1, frameRate: 10, buttonFrameLength: 5, buttonFrameOffset: 2, frameStops: { }, };
</script>
</p>
<!-- 接下來將 mp4 檔案從 downloads 目錄取出 -->
<div class="winkVideoContainerClass"><video autoplay="autoplay" class="winkVideoClass" controls="controls" data-dirname="/static" data-varname="winkVideoData" height="630" muted="true" width="1008">
<source src="/downloads/Tetris.mp4" type="video/mp4"/></video>
<div class="winkVideoOverlayClass"></div>
<div class="winkVideoControlBarClass"><button class="winkVideoControlBarPlayButtonClass"></button> <button class="winkVideoControlBarPauseButtonClass"></button>
<div class="winkVideoControlBarProgressLeftClass"></div>
<div class="winkVideoControlBarProgressEmptyMiddleClass"></div>
<div class="winkVideoControlBarProgressRightClass"></div>
</div>
</div>
</div>